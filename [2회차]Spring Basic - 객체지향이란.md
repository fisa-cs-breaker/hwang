# [2회차] Spring Basic - 객체지향이란

생성일: 2024년 2월 24일 오후 3:02

# 스프링 핵심 원리 - 기본편

> **인프런 - 김영한 강의 수강**

[스프링 핵심 원리 - 기본편 강의 - 대시보드 | 인프런 (inflearn.com)](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)
> 

---

---

---

---

## 섹션1 - 객체 지향 설계와 스프링

### 스프링 역사

ELB(Enterprise Java Beans)만 썼던 옛날옛적…

이거 넘 불편행! 내가 만드는 게 더 날듯ㅋ

해서 나온 것 중 하나가 스프링의 기반이 됐다

로드 존슨씨가 책을 냈고 여기 들어있는 개념과 예제 코드가 훗날 스프링의 기반이 됐단 그런 얘기

### 그래서 스프링이란?

스프링 부트, 스프링 프레임워크를 모두 포함한 스프링 생태계 전체를 아울러서 얘기하기도 하고 프레임 워크 그자체나 DI 컨테이너 기술을 뜻하기도 함

스프링에 여러 기술이 있고(나중에 배울거니까) 그걸 더 편리하게 해주는게 **스프링 부트**

### 그럼 스프링은 왜 만든건데?

웹 애플리케이션도 만들고 DB 접근도 편리하게 해주고…

뭐 톰캣이니 뭐니 웹 서버도 자동으로 띄워주는 거? 전자정부 프레임워크?

결국

스프링은 자바 기반 프레임워크고

자바는 객체 지향 언어

스프링은 이 객체 지향이 가진 강력한 특징을 살려내는 프레임워크

***스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크***

### 그렇다면 객체 지향 프로그래밍이란?

단순히 프로그램을 명령어의 목록이 아니라

여러 개의 독립된 단위인 객체의 모임으로 보는 것.

이 객체 간의 협력으로 프로그램이 굴러가게 하는 것

이는 프로그램을 유연하고도 변경이 용이하게 만듦

여기서 가장 중요한 개념인 **‘다형성’** 이 나옴

### 다형성이란

> **역할**과 **구현**으로 구분하는 것
> 

<aside>
💡 ex) 운전자 - 자동차

운전자 역할, 자동차 역할이 있다면

자동차가 어떤 기종이든 어떤 특징을 가지냐와 별개로 운전자는 그 자동차를 운전할 수 있음

</aside>

즉, 운전자는 자동차 역할 그 자체에만 의존하지 그 차가 어떻게 구현되어있는지는 중요하지 않다

그리고 여기서도 중요하게 드러나는 점. 결국 이렇게 역할 즉, 인터페이스를 통일하는 것은 소비자 즉, 클라이언트를 위한다는 것.

결국에는,

역할과 구현으로 구분하면 세상이 단순해지고 유연해지며 변경도 편리해짐.

**장점:**

클라이언트는 대상의 역할=인터페이스만 알면 됨

그 내부 구조=구현을 몰라도 됨

내부 구조, 구현 대상이 바뀐다고 영향을 받지 않음. 결국은 그 역할을 해낼 거니까

다형성의 본질

: 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

그리고, 결국은 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

### 추가적으로, 좋은 객체지향 설계의 5가지 원칙(SOLID)

**Single Responsibility Principle (SRP)**

> **단일 책임 원칙**

한 클래스는 하나의 책임만 가져야 한다.
> 
- 하나의 책임이란 건 모호할 수 있음
- 중요한 기준은 변경
    - 변경이 있을 때, 파급 효과가 적으면 이를 잘 따른 것

**Open/Closed Principle(OCP)**

> **개방-폐쇄 원칙**

소프트웨어 요소는 확장에는 열려 있되, 변경에는 닫혀있어야 한다.
> 
- 아니 확장을 하려면 변경을 해야하는디요?
- 다형성을 활용해봐요~
- 인터페이스를 구현하는 클래스 만들어서 새 기능을 구현해봅시다
- 엥 근데 그래도 구현 객체를 변경하려면 클라이언트 코드 변경해야하는데??
- 객체 생성 및 연관 관계 맺어주는 별도의 설정자가 필요하다~ 이건 나중에

**Liskov Substitution Principle**

> **리스코프 치환의 원칙**

프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> 
- 즉, 다형성의 입장에서 생각해보면 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.
- 인터페이스를 구현한 구현체를 믿고 쓰려면 그 구현체가 기본을 해야한다.
- 단순 컴파일을 성공한다고 지킨게 아니라는 뜻
    - 자동차의 인터페이스의 엑셀 = 앞으로 가게 한다.
    - 근데 내가 이걸 작동은 되게했는데 차가 뒤로 가면? LSP 위반이다~

**Interface Segregation Principle**

> **인터페이스 분리의 원칙**

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
> 
- 자동차 인터페이스를
    - 운전 인터페이스
    - 정비 인터페이스
- 분리하는게 인터페이스도 명확해지고 대체 가능성도 높아짐.

**Dependency Inversion Principle**

> **의존 관계 역전 원칙**

구체화에 의존하는게 아니라 추상화에 의존해야 한다.
> 
- 구현 클래스에 의존하지말고 인터페이스에 의존하라고~
- 근데 이게 또 OCP에서 말한 것처럼 결국은 클라이언트가 구현 클래스를 직접 선택하면
- 클라이언트가 그 구현체를 알고 있으니까 DIP 위반인디?
- 결국 DIP랑 OCP는 뭔가 더 있어야 지킬 수 있음. 다형성만으론 부족행!

### 그래서 스프링에 이 얘기가 왜 나오냐

스프링은 **의존관계, 의존성 주입**이란 **DI(Dependency Injection)** 기술을 통해서 다형성에 OCP,DIP까지 가능하게 지원을 해준다~

즉, 클라이언트의 코드 변경 없이도 기능을 확장할 수 있다.

## 섹션2 - 스프링 핵심 원리 이해1 - 예제 만들기

### 비즈니스 요구사항

![Untitled](%5B2%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%5D%20Spring%20Basic%20-%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20415e21b196de4ef6bfe304173767e262/Untitled.png)

### 회원 도메인 설계

- 협력 관계: 기획자도 볼 수 있는 전체적인 큰 틀
- 클래스 다이어그램: 서버를 실행안했을 때, 인터페이스나 구현체는 볼 수 있는
- 객체 다이어그램: 서버 실행하고 실제 new한 인스턴스끼리 참조 이런~

**협력 관계는**

클라이언트 → 회원 서비스(회원가입, 회원조회) → 회원 저장소

- 회원 저장소
: 빼놓고 그때에 맞춰서 바꾸면 된다는 아이디어
    - 메모리
    - DB
    - 외부 시스템 연ㄴ동
    

**클래스 다이어그램은**

MemberService ← MemberServiceImpl ⇒ MemberRepository

**객체 다이어그램은**

클라이언트 → 회원 서비스 → 메모리 회원 저장소

### 코드 구조

- hello.core.member
    - Grade - enum
        - BASIC
        - VIP
    - Member
        - 변수
            - id
            - name
            - grade
        - 메소드
            - 생성자
            - getter,setter
    - MemberRepository - 인터페이스
        - 메소드
            - `void save(Member member);`
            - `Member findById(Long memberId);`
    - MemoryMemberRepository implements MemberRepository - 구현체
        - 저장소니까 Map같은게 필요해욤
            - 실무에서는 동시성 이슈때문에(한번에 여러 곳에서 접근) Concurrent 해시맵 씀
            
            ```java
            private static Map<Long, Member> store = new HashMap<>();
            ```
            
        - 메소드
            
            ```java
            #회원가입
            @Override
            public void save(Member member){
            	store.put(member.getId(), member);
            }
            
            #회원조회
            @Override
            public Member findById(Long memberId){
            	return stroe.get(memberId);
            }
            ```
            
        
    - MemberService - 인터페이스
        - 기능 두가지 회원 가입, 회원 조회
            - `void join(Member member);`
            - `Member findMember(Long memberId);`
            
    - MemberServiceImpl implements MemberService - 구현체
        - `@Override void join(Member member);`
        - `@Override Member findMember(Long memberId);`