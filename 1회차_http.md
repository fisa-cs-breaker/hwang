# [1회차] http

생성일: 2024년 2월 24일 오후 3:02

---

# [FISA-CS-Breaker_1_http]

## 개요

### http란?

> HyperText Transfer Protocol

텍스트 기반의 통신 규악. 웹에서 서버-클라이언트가 데이터를 주고받을 수 있는 프로토콜
> 
- 애플리케이션(응용) 계층 프로토콜 ⇒ 네트워크 장치 간에 정보를 전송하도록 설계됨
- 처음에는 www상의 하이퍼텍스트 형태의 문서를 전달하는데 주로 이용했지만,
    - 현재에는 이미지, 비디오, 오디오 등 거의 모든 형식의 데이터 전송 가능

<aside>
❓ HyperText란?

일반 텍스트와 달리 문장이나 단어 등이 링크를 통해 서로 연결된 네트워크처럼 구성된 문서

</aside>

## 동작 방식

> 클라이언트가 브라우저를 통해서 어떤 서비스를 URI를 통해 **요청**하면,
서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 **응답**하는 형태
> 

ex)

사용자가 프로그램에서 로그인 시도하면, 서버로 그 정보를 보냄.(요청)

서버는 그 정보를 확인해서 로그인 시켜줌(응답)

이 때, 클라이언트와 서버 간의 교류가 HTTP라는 규약을 이용함.

## 특징

- TCP/IP 이용하는 **응용 계층** 프로토콜
- 연결 상태 유지하지 않는 **비연결성** 프로토콜
    - 매번 연결해서 느려지는 것 보완하고자 KeepAlive와 같은 속성 활용
- 클라이언트의 상태를 기억하지 않는 **무상태성**(Stateless) 프로토콜
    - 이 때문에 Cookie, Session 활용함
- HTTP 메세지는 HTTP 서버와 HTTP 클라이언트에 의해 해석 됨.
- 기본 포트번호: 80
- https 포트번호: 443

## 헤더

> 요청/응답 시 부가적 정보를 전송할 수 있도록 해줌
> 

크게 네 종류가 있음

### **General header**

요청과 응답 모두에 적용되지만, 바디에서 최종적으로 전달되는 데이터와는 관련 없음

- Date
- Connection
    - Keep-Alive
    : 메세지 교환 후 TCP 연결 유지
        - 비연결성 프로토콜인 http 보완

### **Request header**

패치될 리소스나 클라이언트 자체에 대한 정보 포함하는 헤더. 즉, 내가 보내는 메세지의 헤더

- Host
    - 요청하는 자의 호스트 명, 포트 번호 포함
- User-Agent
    - 요청자의 소프트웨어 정보 표현
- Accept
    - 요청자가 원하는 미디어의 타입 및 우선순위 표현
    - 부속 속성
        - Accept-Language : 사용자가 원하는 언어셋
        - Accept-Encoding : 사용자가 원하는 인코딩 방식
- cookie
    - 서버에 의해서 이전에 저장된 쿠키 포함시키는 속성
- referer
    - 현재 요청을 보낸 페이지의 절대/부분 주소 포함

### **Response header**

서버 자체에 대한 정보와 같이 응답에 대한 부가적 정보 갖는 헤더. 즉, 내가 받는 메세지의 헤더

- Server
    - 서버 소프트웨어의 정보 표현
- content-encoding
    - 응답하는 내용의 인코딩 포맷 표현
- content-type
    - 응답하는 내용의 타입과 문자 포맷 표현
- cache-control
    - 캐시 관리에 대한 정보 표현
    - 캐시 사용 가능한지, 만료 캐시가 뭔지, 유효기간등
- date
    - 응답 메세지가 생성된 시간 표현
- vary
    - 캐시된 응답을 향후에 응답에 사용할 기준
- Set-Cookie
    - 서버에서 사용자에게 세션 쿠키 정보 전달
- Age
    - max-age내에서 캐시가 얼마나 지났는지 초단위로! 표현

### **Entity header**

컨텐츠 길이나 MIME 타입과 같은 엔티티 바디에 대한 정보 포함하는 헤더

- Content-Length
    - 바이트 단위를 가지는 헤더+바디 크기를 나타냄
    - 메세지 크기에 따라 자동으로 생성
- Content-Type
    - 미디어 타입(MIME)과 문자열 인코딩 타입 지정
    - Request의 Accept 헤더와 대응됨
- Content-Language
    - 텍스트뿐만 아니라 미디어 타입에도 적용됨
- Content-Encoding

## 메소드

> 클라이언트 - 서버 구조에서 요청과 응답이 이뤄지는 **방식**

서버가 수행해야 할 동작을 지정하여 요청 보낸다고 생각하면 됨
> 

<aside>
❓ 왜 HTTP 메소드를 사용할까?

⇒ 리소스와 동작을 분리하려고
메소드를 통해 서버가 수행해야 할 동작 지정하면, URI는 리소스만! 식별하면 되니까

</aside>

### GET

리소스를 조회하는 메소드

```
GET /members/100?username=inpa&height=200
```

- URI 입력이나, 링크를 클릭하는 경우
- **멱등성**이란 개념 ⇒ 여러 번 조회 요청해도 리소스는 안 변함.
- GET 요청에서 서버에 데이터 전달하는 경우에는 **쿼리스트링** 통해서 전달
    - **이 때, 클라이언트에게 전달하는 데이터 정보가 무방비 상태로 노출되므로 유의해야 함.**
- **캐싱을 활용해서, 조회 속도가 POST에 비해 우수**

### POST

리소스를 생성하는 메소드

```
POST /user
body : {date : "example"}
Content-Type : "application/json"
```

- 데이터를 메세지 바디에 쿼리 파라미터 형식으로 전달
    - 쿼리 파라미터 : key-value형식으로 돼있음.
    - **이는 데이터가 외부로 노출되지 않으므로, 보안상의 이점 있음.**
- post로도 리소스 조회가능하긴 한데, 얘는 **멱동성 없으**니까 수행할 때마다 결과 바뀔수도~
- 데이터 전송 시, 바디에 담아서 보내므로 메세지 길이에 제한이 없음
- 단순 문자열 데이터뿐만 아니라, 객체들 값도 전송 가능

### PUT

리소스를 완전히 대체하는 메소드 (덮어쓰기)

```
PUT /user/1
body : {date : "update example"}
Content-Type : "application/json"
```

- 클라이언트가 리소스 식별할 수 있음
    - 구체적인 리소스 위치 아는 상태에서 URI 지정함
- 부분 수정 불가능.
- **멱등성 지님**

### PATCH

리소스를 부분 변경하는 메소드

```
PATCH /members/100 HTTP/1.1
Content-Type: application/json 

{ "age": 50 }
```

- PUT 처럼 수정하는 역할, 하지만 얘는 부분 변경한다는 점에 차이가 있음
- **멱등성 지니지 않음**
- PATCH 메서드 지원하지 않는 서버 있으면 POST 사용함

### DELETE

리소스 제거하는 메소드

```
DELETE /user/1
```

- **멱등성 지님**

## 상태 코드

> HTTP 요청이 성공했는지 실패했는지 서버에서 알려주는 숫자 코드

[https://hongong.hanbit.co.kr/http-상태-코드-표-1xx-5xx-전체-요약-정리/](https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/)
> 

### 100번대 - Informational

요청이 수신되어 처리중

| 1XX | Informational | 정보 제공 | 클라이언트의 요청을 받았으며 작업을 계속 진행하고 있다.1xx 계열의 응답은 HTTP/1.1 클라이언트에게만 보낼 수 있으며 응답은 바디 없이 상태 라인, 헤더(생략 가능), 빈 줄로 종료됩니다. |
| --- | --- | --- | --- |
| 100 | Continue | 계속 | 계속 진행하라.클라이언트는 요청 헤더에 ‘Expect: 100-continue’를 보내고 서버는 이를 처리할 수 있으면 이 코드로 응답합니다. |
| 101 | Switching Protocols | 프로토콜 전환 | 프로토콜을 전환하라.프로토콜을 HTTP 1.1에서 업그레이드할 때 Upgrade 응답 헤더에 표시합니다. 현재는 HTTP 1.1이 최신이므로 사용할 일이 없습니다. |
| 102 | Processing | 처리중 | (WebDAV) 처리 중이다.서버가 처리하는 데 오랜 시간이 예상되어 클라이언트에서 타임 아웃이 발생하지 않도록 이 응답 코드를 보냅니다. |
| 103 ~ 199 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

### 200번대 - Success

요청 정상 처리

| 2XX | Success | 성공 | 클라이언트가 요청한 동작을 수신하여 이해하였고 승낙하였으며 성공적으로 처리하였다. |
| --- | --- | --- | --- |
| 200 | OK | 성공 | 서버가 요청을 성공적으로 처리하였다. |
| 201 | Created | 생성됨 | 요청이 처리되어서 새로운 리소스가 생성되었다.응답 헤더 Location에 새로운 리소스의 절대 URI를 기록합니다. |
| 202 | Accepted | 허용됨 | 요청은 접수하였지만, 처리가 완료되지 않았다.응답 헤더의 Location, Retry-After를 참고하여 클라이언트는 다시 요청을 보냅니다. |
| 203 | Non-AuthoritativeInformation | 신뢰할 수 없는정보 | 응답 헤더가 오리지널 서버로부터 제공된 것이 아니다.프록시 서버가 응답 헤더에 주석을 덧붙인 경우가 하나의 예입니다. |
| 204 | No Content | 콘텐츠 없음 | 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없다.응답에는 헤더만 있고 바디는 없습니다. DELETE 요청에 대한 응답에 많이 사용됩니다. |
| 205 | Reset Content | 콘텐츠 재설정 | 처리를 성공하였고 브라우저의 화면을 리셋하라.예를 들어 브라우저가 입력 폼을 보여 주고 있을 때 이 응답 코드를 받으면 브라우저는 모든 입력 항목을 리셋하고 재입력할 수 있는 상태가 됩니다. |
| 206 | Partial Content | 일부 콘텐츠 | 콘텐츠의 일부만을 보낸다.응답 헤더의 Content-Range에 응답 콘텐츠의 범위를 기록합니다. 예를 들어 1,500 바이트의 리소스 중에서 처음의 500바이트만을 보낼 때 사용할 수 있습니다. |
| 207 | Multi-Status | 다중 상태 | (WebDAV) 처리 결과의 스테이터스가 여러 개이다.207 응답은 성공을 뜻하지만, 각각의 처리 결과가 성공인지는 바디를 봐야 알 수 있습니다. |
| 208 ~ 299 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

### 300번대 - Redirection

요청 완료하려면 추가 행동 필요

| 3XX | Redirection | 리다이렉션 | 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다. |
| --- | --- | --- | --- |
| 300 | Multiple Choices | 여러 선택항목 | 선택 항목이 여러 개 있다.지정한 URI에 대해서 콘텐츠 협상을 수행한 결과 서버에서 콘텐츠를 결정하지 못하고 클라이언트에게 복수 개의 링크를 응답할 때 사용합니다. |
| 301 | Moved Permanently | 영구 이동 | 지정한 리소스가 새로운 URI로 이동하였다.이동할 곳의 새로운 URI는 응답 헤더 Location에 기록합니다. |
| 302 | Found | 다른 위치 찾음 | 요청한 리소스를 다른 URI에서 찾았다.요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 302의 의미를 정확하게 개선해서 307을 정의하였으므로 이 응답 코드의 사용은 권장하지 않습니다. |
| 303 | See Other | 다른 위치 보기 | 다른 위치로 요청하라.요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할 수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드입니다. |
| 304 | Not Modified | 수정되지 않음 | 마지막 요청 이후 요청한 페이지는 수정되지 않았다.If-Modified-Since와 같은 조건부 GET 요청일 때 지정한 리소스가 갱신되지 않았음을 알려 줍니다. 이 응답 코드에는 바디가 없습니다. |
| 305 | Use Proxy | 프록시 사용 | 지정한 리소스에 액세스하려면 프록시를 통해야 한다.응답 헤더 Location에 프록시의 URI를 기록합니다. |
| 306 | (Unused) |  | 예전 버전에서 사용하다가 현재는 사용하지 않는 상태 코드입니다. |
| 307 | Temporary Redirect | 임시 리다이렉션 | 임시로 리다이렉션 요청이 필요하다.요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다. 302의 의미를 정확하게 재정의해서 HTTP/1.1의 307 응답으로 추가되었습니다. |
| 308~399 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

### 400번대 - Client Error

클라이언트 오류, 잘못된 문법등 잘못된 요청으로 서버가 요청 수행 불가능

| 4XX | Client Error | 클라이언트 에러 | 클라이언트의 요청에 오류가 있다. |
| --- | --- | --- | --- |
| 400 | Bad Request | 잘못된 요청 | 요청의 구문이 잘못되었다.클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다. |
| 401 | Unauthorized | 권한 없음 | 지정한 리소스에 대한 액세스 권한이 없다.응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다. |
| 402 | Payment Required | 결제 필요 | 지정한 리소스를 액세스하기 위해서는 결제가 필요하다.이 응답 코드는 실제로는 사용되지 않습니다. |
| 403 | Forbidden | 금지됨 | 지정한 리소스에 대한 액세스가 금지되었다.401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미합니다. 리소스의 존재 자체를 은폐하고 싶은 경우는 404 응답 코드를 사용할 수 있습니다. |
| 404 | Not Found | 찾을 수 없음 | 지정한 리소스를 찾을 수 없다. |
| 405 | Method Not Allowed | 허용되지 않은메소드 | 요청한 URI가 지정한 메소드를 지원하지 않는다.응답 헤더 Allow에 이 URI가 지원하는 메소드 목록을 기록합니다. |
| 406 | Not Acceptable | 수용할 수 없음 | 클라이언트가 Accept-* 헤더에 지정한 항목에 관해 처리할 수 없다.응답 바디에는 300 응답처럼 서버가 수용 가능한 다른 선택지 리스트가 기록됩니다. |
| 407 | Proxy AuthenticationRequired | 프록시 인증 필요 | 클라이언트는 프록시 서버에 인증이 필요하다.프록시 서버의 응답 헤더 Proxy-Authenticate에 필요한 인증 방식을 지정합니다. |
| 408 | Request Timeout | 요청 시간초과 | 요청을 기다리다 서버에서 타임아웃하였다. |
| 409 | Conflict | 충돌 | 서버가 요청을 수행하는 중에 충돌이 발생하였다.예를 들어 사용자명을 new_name으로 변경하려 하였지만, 서버에 이미 new_name이라는 사용자가 존재하는 경우입니다. 응답 헤더 Location에는 충돌이 발생한 리소스의 URI를 기록합니다. |
| 410 | Gone | 사라짐 | 지정한 리소스가 이전에는 존재하였지만, 현재는 존재하지 않는다.예를 들어 기간이 한정된 프로모션 사이트가 사라진 경우 사용할 수 있는 응답 코드입니다. |
| 411 | Length Required | 길이 필요 | 요청 헤더에 Content-Length를 지정해야 한다. |
| 412 | Precondition Failed | 사전 조건 실패 | If-Match와 같은 조건부 요청에서 지정한 사전 조건이 서버와 맞지 않는다. |
| 413 | Request EntityToo Large | 요청 객체가너무 큼 | 요청 메시지가 너무 크다.서버는 접속을 끊습니다. |
| 414 | Request-URIToo Large | 요청 URI가너무 긺 | 요청 URI가 너무 길다. |
| 415 | UnsupportedMedia Type | 지원되지 않는미디어 유형 | 클라이언트가 지정한 미디어 타입을 서버가 지원하지 않는다.예를 들어 서버가 지원하는 이미지는 JPG, PNG뿐인데 클라이언트가 GIF 형식의 이미지를 요청하는 경우입니다. |
| 416 | Range Not Satisfiable | 처리할 수 없는요청 범위 | 클라이언트가 지정한 리소스의 범위가 서버의 리소스 사이즈와 맞지 않는다. |
| 417 | Expectation Failed | 예상 실패 | 클라이언트가 지정한 Expect 헤더를 서버가 이해할 수 없다. |
| 418 ~ 421 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |
| 422 | Unprocessable Entity | 처리할 수 없는엔티티 | (WebDAV) 클라이언트가 송신한 XML이 구문은 맞지만, 의미상 오류가 있다. |
| 423 | Locked | 잠김 | (WebDAV) 지정한 리소스는 잠겨있다. |
| 424 | Failed Dependency | 의존 관계로 실패 | (WebDAV) 다른 작업의 실패로 인해 본 요청도 실패하였다. |
| 426 | Upgraded Required | 업그레이드필요함 | 클라이언트의 프로토콜의 업그레이드가 필요하다.응답에 Upgrade 헤더를 보내 필요한 프로토콜을 알려 줍니다. |
| 428 | Precondition Required | 사전 조건 필요함 | If-Match와 같은 사전조건을 지정하는 헤더가 필요하다.If-Match 헤더가 있지만, 맞지 않는 경우는 412 응답을 보냅니다. |
| 429 | Too Many Requests | 너무 많은 요청 | 클라이언트가 주어진 시간 동안 너무 많은 요청을 보냈다.요청의 속도를 제한할 때 사용합니다.  응답에 Retry-After 헤더를 보내 얼마나 기다릴지를 알려 줄 수 있습니다. |
| 431 | Request Header Fields Too Large | 너무 큰 헤더 | 헤더의 길이가 너무 크다.헤더의 전체 크기가 크거나 또는 하나의 헤더가 매우 큰 경우입니다. 보통 Referer URL이 길거나 쿠키 항목이 많은 경우입니다. |
| 444 | Connection Closed Without Response | 응답 없이연결 닫음 | (NGINX) 응답을 보내지 않고 연결을 종료하였다.보통 악의적인 요청에 대해서 사용하며 클라이언트에서는 응답을 볼 수 없고 Nginx 로그에는 나타납니다. |
| 451 | Unavailable For Legal Reasons | 법적 사유로 불가 | 법적으로 문제가 있는 리소스를 요청하였다. |
| 452 ~ 499 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

### 500번대 - Server Error

서버 오류, 서버 내부에서 정상적으로 요청 처리 못함

| 5XX | Server Error | 서버 에러 | 클라이언트의 요청은 유효한데 서버가 처리에 실패하였다. |
| --- | --- | --- | --- |
| 500 | Internal Server Error | 내부 서버 오류 | 서버에 에러가 발생하였다.클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다. |
| 501 | Not Implemented | 구현되지 않음 | 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다. |
| 502 | Bad Gateway | 불량 게이트웨이 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다. |
| 503 | Service Unavailable | 서비스 제공불가 | 현재 서버에서 서비스를 제공할 수 없다.보통은 서버의 과부하나 서비스 점검 등 일시적인 상태입니다. |
| 504 | Gateway Timeout | 게이트웨이 시간초과 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 타임아웃이 발생하였다. |
| 505 | HTTP Version Not Supported | HTTP 버전미지원 | 클라이언트가 요청에 사용한 HTTP 버전을 서버가 지원하지 않는다. |
| 506 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |
| 507 | Insufficient Storage | 용량 부족 | (WebDAV) 서버에 저장 공간 부족으로 처리에 실패하였다. |
| 512 ~ 599 | Unassigned |  | 현재 할당되지 않은 상태 코드입니다. |

## https

> HTTP에 S(Secure Socket)가 추가된 프로토콜

데이터를 주고 받는 과정에 보안적인 요소가 추가됨
서버와 클라이언트 사이의 모든 통신 내용이 암호화됨.
> 
- 페이지를 암호화한 키가 그 페이지를 보는 특정 사용자에게만 알려지도록 함.
- SSL이나 TLS 프로토콜 통해 세션 데이터 암호화함
- 포트번호 443
- SSL 프로토콜 위에서 HTTPS 프로토콜이 동작함
- 공개키 암호화 방식과 대칭키 암호화 방식 함께 사용함
    - 공개키 방식으로 대칭키 전달하고
    - 서로 공유된 대칭키를 가지고 통신함

### 장단점

- 웹사이트의 무결성 보호
- 침입자가 몰래 통신을 수신하는것 방지함으로써 보안 강화
- 사용자의 명시적 권한 허락 가능하게함
- 검색 엔진 최적화에 적용 → 키워드 검색 시 상위 노출되는 기준 중 하나가 보안 요소라서
- 모든 사이트에서 텍스트 암호화하면 과부하걸려서 속도 느려질수도
- 무조건 안전한건 아님. 자체적으로 인증서 발급할 수도 있고, 믿지못할 CA기업 통해서 인증서 발급받을 수도 있으니까